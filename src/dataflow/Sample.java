package dataflow;

public class Sample {
	
	public static void main(String[] args){
		int result = 0;
		
		for(int i = 0; i < 10; i++){
			result = i + 1 + result;
		}
		
		System.out.println(result);
		
	}

}

/*

 1. データキャッシュ
 　1.1. ゾーニング
 　　シスステムがリクエストを受け付けるフロントサイド側からのキャッシュポイントを増加させる。
 　　1.1.1. web server でのキャッシュレスポンスによる性能向上
 　　1.1.2. Application Server(servlet)でのキャッシュレスポンスによる性能向上
 　　1.1.3. DB Acccess Object(DAO) キャッシュによる性能向上
 　　1.1.4. DB Connectionオブジェクトのキャッシュ(static化）による性能向上
 　　1.1.5. DBMSのメモリーキャッシュによる性能向上
 2. アーキテクチャー
 　　処理システムの処理方式を見直すことで性能を改善させる。
 　2.1.クラスター化
 　　2.1.1.水平クラスター
 　　2.1.2.垂直クラスター
 　2.2.負荷分散
 　　2.2.1. ラウンドロビン
 　2.3. バッチ処理
    処理時間性能が求められる処理・昨日をバッチ処理化することで集中的な計算リソースのアロケーションをおこない性能を強化する
 　　2.3.1. 純バッチ
 　　2.3.2. 夜間バッチ
 　　2.3.3. ディレードバッチ（オン中バッチ）
 　　2.3.4. 分散バッチ＋分散DB（MapReduce, spark）
 　　2.3.5. ストリームバッチ（Kafka)
  2.4.ノンブロッキングシステム化
  　node.jsのように１リクエストや１ユーザー個別に専用プロセスを立ち上げ、プロセスごとにリクエスト処理をさせることで、クラウドのような動的なスケールアップが可能な基盤上での処理性能向上を測る
 3. プロジェクトマネージメント
 　3.1. 非機能要件の確認
 　　顧客と定めたSLAや非機能要件を確認し、現在の性能が当初の要件通りであるか確認し、要件通りであれば顧客に説明を行い、性能向上の為の追加コスト要求、変更管理を実施する。
 　3.2. サイジング要件の確認
 　　HWのサイジングが当初想定したSLAと乖離がないか確認する。サイジング不備の場合は、要件定義の仕様バグとして変更管理を行う。
 　3.3. コンチプランの発動
 　　現状が顧客ビジネスやサービスにクリティカルである場合、サービス提供ができない場合のコンチプランの発動を顧客に提案する。
 　3.4. ROIの算定
 　　顧客の求める性能要求がサービスリリース後の採算として真に有益であるかコスト面での優位性を明確にし、サービスを継続するか、スケールアップするかの判断を提案する。
 4. DBチューニング
 　4.1.インデックスの作成
 　4.2.TBLの結合SQLの見直し
 　4.3.実行計画の見直し、固定化
 　4.4.自由検索処理のタイムアウト時間の短縮
   4.5.各メモリー領域の容量見直し
 5. Application Serverチューニング
 　5.1. ヒープサイズの拡張
 　5.2. ガーベージコレクションログの停止
 　5.3. systemログの出力範囲・レベルの限定
 　5.4. デプロイされているアプリのログ出力範囲・レベルの限定
 　5.5. ワークマネージャーによる本来禁止されているsevlet処理内でのマルチスレッド化
 　5.6. web, DBのコネクション数の最適化
  
 
 
 */

